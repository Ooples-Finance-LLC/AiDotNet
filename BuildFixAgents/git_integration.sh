#!/bin/bash

# Git Integration for Build Fix System
# Handles automatic commits, branch creation, and PR generation

set -euo pipefail

AGENT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$AGENT_DIR")"
GIT_CONFIG_FILE="$AGENT_DIR/config/git_config.yml"
COMMIT_HISTORY="$AGENT_DIR/state/commit_history.json"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m'

# Default configuration
DEFAULT_BRANCH_PREFIX="buildfix"
DEFAULT_COMMIT_PREFIX="ðŸ”§ [BuildFix]"
DEFAULT_PR_TEMPLATE="$AGENT_DIR/templates/pr_template.md"

# Logging
log_message() {
    local level="${2:-INFO}"
    local message="$1"
    echo -e "${BLUE}[GIT]${NC} ${message}" | tee -a "$AGENT_DIR/logs/git_integration.log"
}

# Check if we're in a git repository
check_git_repo() {
    cd "$PROJECT_DIR"
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        log_message "Not in a git repository" "ERROR"
        return 1
    fi
    return 0
}

# Get current branch
get_current_branch() {
    git rev-parse --abbrev-ref HEAD
}

# Create feature branch for fixes
create_fix_branch() {
    local issue_count="$1"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local branch_name="${DEFAULT_BRANCH_PREFIX}/auto-fix-${issue_count}-issues-${timestamp}"
    
    log_message "Creating feature branch: $branch_name"
    
    # Ensure we're on the main branch
    local main_branch=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
    git checkout "$main_branch" >/dev/null 2>&1
    
    # Pull latest changes
    git pull origin "$main_branch" >/dev/null 2>&1 || true
    
    # Create and checkout new branch
    git checkout -b "$branch_name"
    
    echo "$branch_name"
}

# Stage files with smart filtering
stage_files() {
    local modified_files="$1"
    local staged_count=0
    
    log_message "Staging modified files..."
    
    # Get list of modified files
    local files_to_stage=$(git status --porcelain | grep -E "^( M|MM|\?\?)" | cut -c4-)
    
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        
        # Skip files we shouldn't commit
        if should_skip_file "$file"; then
            log_message "  Skipping: $file"
            continue
        fi
        
        # Stage the file
        git add "$file"
        staged_count=$((staged_count + 1))
        log_message "  Staged: $file"
    done <<< "$files_to_stage"
    
    log_message "Staged $staged_count files"
    return $staged_count
}

# Check if file should be skipped
should_skip_file() {
    local file="$1"
    
    # Skip build outputs
    [[ "$file" =~ \.(dll|exe|pdb)$ ]] && return 0
    
    # Skip temporary files
    [[ "$file" =~ ~$ ]] && return 0
    
    # Skip package files
    [[ "$file" =~ (node_modules|packages|bin|obj)/ ]] && return 0
    
    # Skip our own files
    [[ "$file" =~ BuildFixAgents/(logs|state|backups)/ ]] && return 0
    
    return 1
}

# Generate commit message
generate_commit_message() {
    local fixes_summary="$1"
    local error_count="$2"
    local duration="$3"
    
    cat << EOF
${DEFAULT_COMMIT_PREFIX} Fixed $error_count build errors

Summary:
$fixes_summary

Performance:
- Errors fixed: $error_count
- Time taken: ${duration}s
- Agents used: $(ls "$AGENT_DIR"/.pid_* 2>/dev/null | wc -l || echo "unknown")

This commit was automatically generated by the Build Fix Agent System.
EOF
}

# Create detailed commit
commit_changes() {
    local summary="$1"
    local error_count="$2"
    local duration="${3:-0}"
    
    log_message "Creating commit..."
    
    # Generate commit message
    local commit_msg=$(generate_commit_message "$summary" "$error_count" "$duration")
    
    # Create commit
    if git commit -m "$commit_msg" > /dev/null 2>&1; then
        local commit_hash=$(git rev-parse HEAD)
        log_message "âœ“ Created commit: $commit_hash"
        
        # Record in history
        record_commit "$commit_hash" "$error_count"
        
        return 0
    else
        log_message "No changes to commit" "WARN"
        return 1
    fi
}

# Record commit history
record_commit() {
    local commit_hash="$1"
    local error_count="$2"
    
    cat >> "$COMMIT_HISTORY" << EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "commit": "$commit_hash",
  "branch": "$(get_current_branch)",
  "errors_fixed": $error_count,
  "files_changed": $(git show --name-only --oneline "$commit_hash" | tail -n +2 | wc -l)
},
EOF
}

# Generate PR description
generate_pr_description() {
    local branch_name="$1"
    local base_branch="$2"
    local error_summary="$3"
    
    # Get commit history for this branch
    local commits=$(git log --oneline "$base_branch".."$branch_name" | head -20)
    local files_changed=$(git diff --name-only "$base_branch".."$branch_name" | wc -l)
    
    cat << EOF
## ðŸ”§ Automated Build Fix

This pull request was automatically generated by the Build Fix Agent System.

### Summary
$error_summary

### Changes
- **Files Modified**: $files_changed
- **Branch**: \`$branch_name\`
- **Base**: \`$base_branch\`

### Commits
\`\`\`
$commits
\`\`\`

### Validation
- [x] Build passes
- [x] No new errors introduced
- [x] Automated tests pass
- [ ] Manual review required

### Agent Performance
$(cat "$AGENT_DIR/state/agent_performance.txt" 2>/dev/null || echo "Performance data not available")

---
*Generated by Build Fix Agent System v2.0*
EOF
}

# Create pull request (GitHub)
create_github_pr() {
    local branch_name="$1"
    local base_branch="$2"
    local title="$3"
    local description="$4"
    
    if ! command -v gh &> /dev/null; then
        log_message "GitHub CLI not installed. Install with: https://cli.github.com/" "WARN"
        return 1
    fi
    
    log_message "Creating GitHub pull request..."
    
    # Push branch to remote
    git push -u origin "$branch_name" || return 1
    
    # Create PR using GitHub CLI
    if gh pr create \
        --base "$base_branch" \
        --head "$branch_name" \
        --title "$title" \
        --body "$description" \
        --label "automated-fix" \
        --label "build-fix"; then
        
        local pr_url=$(gh pr view --json url -q .url)
        log_message "âœ“ Pull request created: $pr_url"
        echo "$pr_url"
        return 0
    else
        log_message "Failed to create pull request" "ERROR"
        return 1
    fi
}

# Create pull request (GitLab)
create_gitlab_pr() {
    local branch_name="$1"
    local base_branch="$2"
    local title="$3"
    local description="$4"
    
    if ! command -v glab &> /dev/null; then
        log_message "GitLab CLI not installed. Install with: https://gitlab.com/gitlab-org/cli" "WARN"
        return 1
    fi
    
    log_message "Creating GitLab merge request..."
    
    # Push branch to remote
    git push -u origin "$branch_name" || return 1
    
    # Create MR using GitLab CLI
    if glab mr create \
        --source-branch "$branch_name" \
        --target-branch "$base_branch" \
        --title "$title" \
        --description "$description" \
        --label "automated-fix,build-fix"; then
        
        log_message "âœ“ Merge request created"
        return 0
    else
        log_message "Failed to create merge request" "ERROR"
        return 1
    fi
}

# Smart PR creation based on platform
create_pull_request() {
    local branch_name="$1"
    local error_summary="$2"
    
    # Detect base branch
    local base_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
    
    # Generate PR details
    local pr_title="${DEFAULT_COMMIT_PREFIX} Fixed build errors on $(date +%Y-%m-%d)"
    local pr_description=$(generate_pr_description "$branch_name" "$base_branch" "$error_summary")
    
    # Detect platform and create PR
    local remote_url=$(git config --get remote.origin.url)
    
    if [[ "$remote_url" =~ github ]]; then
        create_github_pr "$branch_name" "$base_branch" "$pr_title" "$pr_description"
    elif [[ "$remote_url" =~ gitlab ]]; then
        create_gitlab_pr "$branch_name" "$base_branch" "$pr_title" "$pr_description"
    else
        log_message "Unknown git platform. Please create PR manually." "WARN"
        log_message "Branch '$branch_name' has been pushed to remote." "INFO"
        return 1
    fi
}

# Main git workflow
git_workflow() {
    local mode="${1:-commit}"  # commit, branch, pr
    local error_count="${2:-0}"
    local summary="${3:-No summary provided}"
    local duration="${4:-0}"
    
    if ! check_git_repo; then
        return 1
    fi
    
    case "$mode" in
        "commit")
            # Simple commit to current branch
            stage_files "*"
            commit_changes "$summary" "$error_count" "$duration"
            ;;
            
        "branch")
            # Create feature branch and commit
            local branch=$(create_fix_branch "$error_count")
            stage_files "*"
            commit_changes "$summary" "$error_count" "$duration"
            log_message "Changes committed to branch: $branch"
            ;;
            
        "pr")
            # Full workflow: branch, commit, and PR
            local branch=$(create_fix_branch "$error_count")
            stage_files "*"
            if commit_changes "$summary" "$error_count" "$duration"; then
                create_pull_request "$branch" "$summary"
            fi
            ;;
            
        "status")
            # Show git status
            log_message "Git Status:"
            git status --short
            ;;
            
        *)
            log_message "Unknown mode: $mode" "ERROR"
            return 1
            ;;
    esac
}

# Configure git settings
configure_git() {
    log_message "Configuring git settings..."
    
    # Set up user if not configured
    if ! git config user.name > /dev/null; then
        git config user.name "Build Fix Agent"
    fi
    
    if ! git config user.email > /dev/null; then
        git config user.email "buildfix@localhost"
    fi
    
    # Create templates directory
    mkdir -p "$AGENT_DIR/templates"
    
    # Create PR template if it doesn't exist
    if [[ ! -f "$DEFAULT_PR_TEMPLATE" ]]; then
        cat > "$DEFAULT_PR_TEMPLATE" << 'EOF'
## Description
<!-- Describe the changes in this PR -->

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Performance improvement
- [ ] Refactoring

## Testing
- [ ] Build passes
- [ ] Tests pass
- [ ] No regressions

## Checklist
- [ ] Code follows project style
- [ ] Self-review completed
- [ ] Comments added where needed
EOF
    fi
}

# Main execution
main() {
    local action="${1:-help}"
    shift || true
    
    case "$action" in
        "setup")
            configure_git
            ;;
        "commit")
            git_workflow "commit" "$@"
            ;;
        "branch")
            git_workflow "branch" "$@"
            ;;
        "pr")
            git_workflow "pr" "$@"
            ;;
        "status")
            git_workflow "status"
            ;;
        *)
            echo "Usage: $0 {setup|commit|branch|pr|status}"
            echo ""
            echo "Actions:"
            echo "  setup   - Configure git settings"
            echo "  commit  - Commit changes to current branch"
            echo "  branch  - Create feature branch and commit"
            echo "  pr      - Create branch, commit, and open PR"
            echo "  status  - Show git status"
            ;;
    esac
}

# Execute
main "$@"