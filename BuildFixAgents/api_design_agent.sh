#!/bin/bash
# API Design Agent - Creates API specifications, OpenAPI docs, and API contracts
# Part of the ZeroDev/BuildFixAgents Multi-Agent System

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
API_STATE="$SCRIPT_DIR/state/api_design"
mkdir -p "$API_STATE/specs" "$API_STATE/contracts" "$API_STATE/mocks"

# Source logging if available
if [[ -f "$SCRIPT_DIR/enhanced_logging_system.sh" ]]; then
    source "$SCRIPT_DIR/enhanced_logging_system.sh"
else
    log_event() { echo "[$1] $2: $3"; }
fi

# Colors
BOLD='\033[1m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Banner
show_banner() {
    echo -e "${BOLD}${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${MAGENTA}║        API Design Agent v1.0           ║${NC}"
    echo -e "${BOLD}${MAGENTA}╚════════════════════════════════════════╝${NC}"
}

# Generate OpenAPI specification
generate_openapi_spec() {
    local api_name="${1:-MyAPI}"
    local version="${2:-1.0.0}"
    local description="${3:-API generated by ZeroDev}"
    local output_file="$API_STATE/specs/openapi.yaml"
    
    log_event "INFO" "API_DESIGN" "Generating OpenAPI specification"
    
    cat > "$output_file" << EOF
openapi: 3.0.3
info:
  title: $api_name
  description: $description
  version: $version
  contact:
    name: API Support
    email: api@example.com
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT

servers:
  - url: https://api.example.com/v1
    description: Production server
  - url: https://staging-api.example.com/v1
    description: Staging server
  - url: http://localhost:3000/v1
    description: Development server

tags:
  - name: Authentication
    description: Authentication endpoints
  - name: Users
    description: User management
  - name: Resources
    description: Resource operations

paths:
  /auth/login:
    post:
      tags:
        - Authentication
      summary: User login
      description: Authenticate user and receive access token
      operationId: loginUser
      requestBody:
        required: true
        content:
          application/json:
            schema:
              \$ref: '#/components/schemas/LoginRequest'
      responses:
        '200':
          description: Successful login
          content:
            application/json:
              schema:
                \$ref: '#/components/schemas/LoginResponse'
        '401':
          \$ref: '#/components/responses/UnauthorizedError'
        '422':
          \$ref: '#/components/responses/ValidationError'

  /auth/refresh:
    post:
      tags:
        - Authentication
      summary: Refresh access token
      operationId: refreshToken
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              \$ref: '#/components/schemas/RefreshRequest'
      responses:
        '200':
          description: Token refreshed
          content:
            application/json:
              schema:
                \$ref: '#/components/schemas/TokenResponse'
        '401':
          \$ref: '#/components/responses/UnauthorizedError'

  /users:
    get:
      tags:
        - Users
      summary: List users
      description: Get a paginated list of users
      operationId: listUsers
      security:
        - bearerAuth: []
      parameters:
        - \$ref: '#/components/parameters/PageParam'
        - \$ref: '#/components/parameters/LimitParam'
        - \$ref: '#/components/parameters/SortParam'
        - name: filter
          in: query
          description: Filter users by status
          schema:
            type: string
            enum: [active, inactive, all]
            default: all
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                \$ref: '#/components/schemas/UserListResponse'
        '401':
          \$ref: '#/components/responses/UnauthorizedError'

    post:
      tags:
        - Users
      summary: Create user
      operationId: createUser
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              \$ref: '#/components/schemas/CreateUserRequest'
      responses:
        '201':
          description: User created
          content:
            application/json:
              schema:
                \$ref: '#/components/schemas/UserResponse'
          headers:
            Location:
              description: URL of created resource
              schema:
                type: string
        '401':
          \$ref: '#/components/responses/UnauthorizedError'
        '422':
          \$ref: '#/components/responses/ValidationError'

  /users/{userId}:
    parameters:
      - \$ref: '#/components/parameters/UserIdParam'
    
    get:
      tags:
        - Users
      summary: Get user by ID
      operationId: getUserById
      security:
        - bearerAuth: []
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                \$ref: '#/components/schemas/UserResponse'
        '401':
          \$ref: '#/components/responses/UnauthorizedError'
        '404':
          \$ref: '#/components/responses/NotFoundError'

    put:
      tags:
        - Users
      summary: Update user
      operationId: updateUser
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              \$ref: '#/components/schemas/UpdateUserRequest'
      responses:
        '200':
          description: User updated
          content:
            application/json:
              schema:
                \$ref: '#/components/schemas/UserResponse'
        '401':
          \$ref: '#/components/responses/UnauthorizedError'
        '404':
          \$ref: '#/components/responses/NotFoundError'
        '422':
          \$ref: '#/components/responses/ValidationError'

    delete:
      tags:
        - Users
      summary: Delete user
      operationId: deleteUser
      security:
        - bearerAuth: []
      responses:
        '204':
          description: User deleted
        '401':
          \$ref: '#/components/responses/UnauthorizedError'
        '404':
          \$ref: '#/components/responses/NotFoundError'

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  parameters:
    UserIdParam:
      name: userId
      in: path
      required: true
      description: User ID
      schema:
        type: string
        format: uuid
    
    PageParam:
      name: page
      in: query
      description: Page number
      schema:
        type: integer
        minimum: 1
        default: 1
    
    LimitParam:
      name: limit
      in: query
      description: Items per page
      schema:
        type: integer
        minimum: 1
        maximum: 100
        default: 20
    
    SortParam:
      name: sort
      in: query
      description: Sort field and order
      schema:
        type: string
        pattern: '^[a-zA-Z_]+:(asc|desc)$'
        example: 'created_at:desc'

  schemas:
    LoginRequest:
      type: object
      required:
        - email
        - password
      properties:
        email:
          type: string
          format: email
          example: user@example.com
        password:
          type: string
          format: password
          minLength: 8
          example: "********"

    LoginResponse:
      type: object
      properties:
        access_token:
          type: string
          description: JWT access token
        refresh_token:
          type: string
          description: Refresh token
        token_type:
          type: string
          enum: [Bearer]
          default: Bearer
        expires_in:
          type: integer
          description: Token expiry in seconds
          example: 3600
        user:
          \$ref: '#/components/schemas/UserResponse'

    RefreshRequest:
      type: object
      required:
        - refresh_token
      properties:
        refresh_token:
          type: string

    TokenResponse:
      type: object
      properties:
        access_token:
          type: string
        token_type:
          type: string
          enum: [Bearer]
        expires_in:
          type: integer

    CreateUserRequest:
      type: object
      required:
        - email
        - name
        - password
      properties:
        email:
          type: string
          format: email
        name:
          type: string
          minLength: 2
          maxLength: 100
        password:
          type: string
          format: password
          minLength: 8
        role:
          type: string
          enum: [user, admin]
          default: user

    UpdateUserRequest:
      type: object
      properties:
        name:
          type: string
          minLength: 2
          maxLength: 100
        email:
          type: string
          format: email
        status:
          type: string
          enum: [active, inactive]

    UserResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        name:
          type: string
        role:
          type: string
          enum: [user, admin]
        status:
          type: string
          enum: [active, inactive]
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time

    UserListResponse:
      type: object
      properties:
        data:
          type: array
          items:
            \$ref: '#/components/schemas/UserResponse'
        pagination:
          \$ref: '#/components/schemas/PaginationMeta'

    PaginationMeta:
      type: object
      properties:
        page:
          type: integer
        limit:
          type: integer
        total:
          type: integer
        total_pages:
          type: integer

    Error:
      type: object
      required:
        - code
        - message
      properties:
        code:
          type: string
        message:
          type: string
        details:
          type: object

    ValidationError:
      allOf:
        - \$ref: '#/components/schemas/Error'
        - type: object
          properties:
            errors:
              type: array
              items:
                type: object
                properties:
                  field:
                    type: string
                  message:
                    type: string

  responses:
    UnauthorizedError:
      description: Authentication required
      content:
        application/json:
          schema:
            \$ref: '#/components/schemas/Error'
          example:
            code: "UNAUTHORIZED"
            message: "Authentication required"

    NotFoundError:
      description: Resource not found
      content:
        application/json:
          schema:
            \$ref: '#/components/schemas/Error'
          example:
            code: "NOT_FOUND"
            message: "Resource not found"

    ValidationError:
      description: Validation error
      content:
        application/json:
          schema:
            \$ref: '#/components/schemas/ValidationError'
          example:
            code: "VALIDATION_ERROR"
            message: "Validation failed"
            errors:
              - field: "email"
                message: "Invalid email format"
EOF
    
    log_event "SUCCESS" "API_DESIGN" "OpenAPI specification generated at $output_file"
}

# Generate API client SDK
generate_client_sdk() {
    local language="${1:-javascript}"
    local api_spec="${2:-$API_STATE/specs/openapi.yaml}"
    local output_dir="$API_STATE/sdks/$language"
    
    mkdir -p "$output_dir"
    
    log_event "INFO" "API_DESIGN" "Generating $language client SDK"
    
    case "$language" in
        javascript)
            generate_js_client "$output_dir"
            ;;
        python)
            generate_python_client "$output_dir"
            ;;
        csharp)
            generate_csharp_client "$output_dir"
            ;;
        *)
            log_event "ERROR" "API_DESIGN" "Unsupported language: $language"
            return 1
            ;;
    esac
}

# Generate JavaScript client
generate_js_client() {
    local output_dir="$1"
    
    # API Client class
    cat > "$output_dir/api-client.js" << 'EOF'
class APIClient {
  constructor(config = {}) {
    this.baseURL = config.baseURL || 'https://api.example.com/v1';
    this.timeout = config.timeout || 30000;
    this.headers = {
      'Content-Type': 'application/json',
      ...config.headers
    };
    this.accessToken = null;
    this.refreshToken = null;
  }

  setAuthToken(accessToken, refreshToken = null) {
    this.accessToken = accessToken;
    this.refreshToken = refreshToken;
    if (accessToken) {
      this.headers['Authorization'] = `Bearer ${accessToken}`;
    } else {
      delete this.headers['Authorization'];
    }
  }

  async request(method, path, options = {}) {
    const url = `${this.baseURL}${path}`;
    const config = {
      method,
      headers: { ...this.headers, ...options.headers },
      ...options
    };

    if (options.body && typeof options.body === 'object') {
      config.body = JSON.stringify(options.body);
    }

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        throw new APIError(response.status, error);
      }

      if (response.status === 204) {
        return null;
      }

      return await response.json();
    } catch (error) {
      if (error instanceof APIError) {
        throw error;
      }
      throw new APIError(0, { message: error.message });
    }
  }

  // Convenience methods
  get(path, options) {
    return this.request('GET', path, options);
  }

  post(path, body, options = {}) {
    return this.request('POST', path, { ...options, body });
  }

  put(path, body, options = {}) {
    return this.request('PUT', path, { ...options, body });
  }

  delete(path, options) {
    return this.request('DELETE', path, options);
  }
}

class APIError extends Error {
  constructor(status, error) {
    super(error.message || 'API Error');
    this.name = 'APIError';
    this.status = status;
    this.code = error.code;
    this.details = error.details;
  }
}

module.exports = { APIClient, APIError };
EOF

    # Auth module
    cat > "$output_dir/auth.js" << 'EOF'
const { APIClient } = require('./api-client');

class AuthAPI {
  constructor(client) {
    this.client = client;
  }

  async login(email, password) {
    const response = await this.client.post('/auth/login', { email, password });
    this.client.setAuthToken(response.access_token, response.refresh_token);
    return response;
  }

  async refresh(refreshToken) {
    const response = await this.client.post('/auth/refresh', { 
      refresh_token: refreshToken || this.client.refreshToken 
    });
    this.client.setAuthToken(response.access_token);
    return response;
  }

  async logout() {
    this.client.setAuthToken(null);
  }
}

module.exports = AuthAPI;
EOF

    # Users module
    cat > "$output_dir/users.js" << 'EOF'
const { APIClient } = require('./api-client');

class UsersAPI {
  constructor(client) {
    this.client = client;
  }

  async list(params = {}) {
    const queryString = new URLSearchParams(params).toString();
    const path = queryString ? `/users?${queryString}` : '/users';
    return this.client.get(path);
  }

  async get(userId) {
    return this.client.get(`/users/${userId}`);
  }

  async create(userData) {
    return this.client.post('/users', userData);
  }

  async update(userId, userData) {
    return this.client.put(`/users/${userId}`, userData);
  }

  async delete(userId) {
    return this.client.delete(`/users/${userId}`);
  }
}

module.exports = UsersAPI;
EOF

    # Main SDK file
    cat > "$output_dir/index.js" << 'EOF'
const { APIClient, APIError } = require('./api-client');
const AuthAPI = require('./auth');
const UsersAPI = require('./users');

class SDK {
  constructor(config = {}) {
    this.client = new APIClient(config);
    this.auth = new AuthAPI(this.client);
    this.users = new UsersAPI(this.client);
  }
}

module.exports = { SDK, APIError };
EOF

    # Package.json
    cat > "$output_dir/package.json" << 'EOF'
{
  "name": "@myapi/sdk",
  "version": "1.0.0",
  "description": "JavaScript SDK for MyAPI",
  "main": "index.js",
  "keywords": ["api", "sdk", "client"],
  "license": "MIT",
  "dependencies": {
    "node-fetch": "^2.6.7"
  }
}
EOF
    
    log_event "SUCCESS" "API_DESIGN" "JavaScript SDK generated"
}

# Generate API contract tests
generate_contract_tests() {
    local framework="${1:-jest}"
    local output_dir="$API_STATE/contracts"
    
    log_event "INFO" "API_DESIGN" "Generating contract tests"
    
    # Pact test example
    cat > "$output_dir/user-contract.test.js" << 'EOF'
const { Pact } = require('@pact-foundation/pact');
const { SDK } = require('../sdks/javascript');
const path = require('path');

describe('User API Contract', () => {
  const provider = new Pact({
    consumer: 'Frontend',
    provider: 'UserService',
    port: 1234,
    log: path.resolve(process.cwd(), 'logs', 'pact.log'),
    dir: path.resolve(process.cwd(), 'pacts'),
    logLevel: 'INFO'
  });

  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());
  afterAll(() => provider.finalize());

  describe('get user', () => {
    beforeEach(() => {
      const interaction = {
        state: 'user 123 exists',
        uponReceiving: 'a request for user 123',
        withRequest: {
          method: 'GET',
          path: '/users/123',
          headers: {
            'Authorization': 'Bearer token'
          }
        },
        willRespondWith: {
          status: 200,
          headers: {
            'Content-Type': 'application/json'
          },
          body: {
            id: '123',
            email: 'user@example.com',
            name: 'Test User',
            role: 'user',
            status: 'active',
            created_at: '2023-01-01T00:00:00Z',
            updated_at: '2023-01-01T00:00:00Z'
          }
        }
      };

      return provider.addInteraction(interaction);
    });

    test('returns user details', async () => {
      const sdk = new SDK({ baseURL: provider.mockService.baseUrl });
      sdk.client.setAuthToken('token');
      
      const user = await sdk.users.get('123');
      
      expect(user.id).toBe('123');
      expect(user.email).toBe('user@example.com');
      expect(user.name).toBe('Test User');
    });
  });
});
EOF
    
    log_event "SUCCESS" "API_DESIGN" "Contract tests generated"
}

# Generate API mock server
generate_mock_server() {
    local output_file="$API_STATE/mocks/mock-server.js"
    
    log_event "INFO" "API_DESIGN" "Generating mock server"
    
    cat > "$output_file" << 'EOF'
const express = require('express');
const { faker } = require('@faker-js/faker');
const jwt = require('jsonwebtoken');

const app = express();
app.use(express.json());

const JWT_SECRET = 'mock-secret';

// Mock data store
const users = new Map();

// Seed some users
for (let i = 0; i < 10; i++) {
  const id = faker.string.uuid();
  users.set(id, {
    id,
    email: faker.internet.email(),
    name: faker.person.fullName(),
    role: faker.helpers.arrayElement(['user', 'admin']),
    status: faker.helpers.arrayElement(['active', 'inactive']),
    created_at: faker.date.past().toISOString(),
    updated_at: faker.date.recent().toISOString()
  });
}

// Middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ code: 'UNAUTHORIZED', message: 'Authentication required' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(401).json({ code: 'UNAUTHORIZED', message: 'Invalid token' });
    }
    req.user = user;
    next();
  });
};

// Routes
app.post('/v1/auth/login', (req, res) => {
  const { email, password } = req.body;
  
  if (!email || !password) {
    return res.status(422).json({
      code: 'VALIDATION_ERROR',
      message: 'Validation failed',
      errors: [
        !email && { field: 'email', message: 'Email is required' },
        !password && { field: 'password', message: 'Password is required' }
      ].filter(Boolean)
    });
  }

  const user = Array.from(users.values()).find(u => u.email === email);
  const access_token = jwt.sign({ sub: user?.id || '123', email }, JWT_SECRET, { expiresIn: '1h' });
  const refresh_token = jwt.sign({ sub: user?.id || '123' }, JWT_SECRET, { expiresIn: '7d' });

  res.json({
    access_token,
    refresh_token,
    token_type: 'Bearer',
    expires_in: 3600,
    user: user || {
      id: '123',
      email,
      name: 'Mock User',
      role: 'user',
      status: 'active',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }
  });
});

app.get('/v1/users', authenticateToken, (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 20;
  const userArray = Array.from(users.values());
  const total = userArray.length;
  const totalPages = Math.ceil(total / limit);
  const start = (page - 1) * limit;
  const data = userArray.slice(start, start + limit);

  res.json({
    data,
    pagination: {
      page,
      limit,
      total,
      total_pages: totalPages
    }
  });
});

app.get('/v1/users/:userId', authenticateToken, (req, res) => {
  const user = users.get(req.params.userId);
  
  if (!user) {
    return res.status(404).json({ code: 'NOT_FOUND', message: 'User not found' });
  }
  
  res.json(user);
});

app.post('/v1/users', authenticateToken, (req, res) => {
  const { email, name, password, role } = req.body;
  
  if (!email || !name || !password) {
    return res.status(422).json({
      code: 'VALIDATION_ERROR',
      message: 'Validation failed',
      errors: [
        !email && { field: 'email', message: 'Email is required' },
        !name && { field: 'name', message: 'Name is required' },
        !password && { field: 'password', message: 'Password is required' }
      ].filter(Boolean)
    });
  }

  const id = faker.string.uuid();
  const user = {
    id,
    email,
    name,
    role: role || 'user',
    status: 'active',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  };
  
  users.set(id, user);
  res.status(201).header('Location', `/v1/users/${id}`).json(user);
});

// Start server
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Mock API server running on http://localhost:${PORT}`);
  console.log(`\nAvailable endpoints:`);
  console.log(`  POST   /v1/auth/login`);
  console.log(`  GET    /v1/users`);
  console.log(`  GET    /v1/users/:id`);
  console.log(`  POST   /v1/users`);
  console.log(`  PUT    /v1/users/:id`);
  console.log(`  DELETE /v1/users/:id`);
});
EOF
    
    # Package.json for mock server
    cat > "$API_STATE/mocks/package.json" << 'EOF'
{
  "name": "api-mock-server",
  "version": "1.0.0",
  "description": "Mock server for API development",
  "main": "mock-server.js",
  "scripts": {
    "start": "node mock-server.js",
    "dev": "nodemon mock-server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "@faker-js/faker": "^8.0.0",
    "jsonwebtoken": "^9.0.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  }
}
EOF
    
    log_event "SUCCESS" "API_DESIGN" "Mock server generated"
}

# Generate API documentation
generate_api_docs() {
    local format="${1:-markdown}"
    local output_file="$API_STATE/API_DOCUMENTATION.md"
    
    log_event "INFO" "API_DESIGN" "Generating API documentation"
    
    cat > "$output_file" << 'EOF'
# API Documentation

## Overview
This API provides a RESTful interface for managing users and authentication.

## Base URL
```
Production: https://api.example.com/v1
Staging: https://staging-api.example.com/v1
Development: http://localhost:3000/v1
```

## Authentication
This API uses JWT (JSON Web Token) for authentication. 

### Obtaining a Token
```bash
POST /auth/login
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "yourpassword"
}
```

Response:
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "user": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "email": "user@example.com",
    "name": "John Doe"
  }
}
```

### Using the Token
Include the token in the Authorization header:
```
Authorization: Bearer YOUR_ACCESS_TOKEN
```

## Error Handling
All errors follow a consistent format:

```json
{
  "code": "ERROR_CODE",
  "message": "Human readable error message",
  "details": {}
}
```

Common error codes:
- `UNAUTHORIZED` - Authentication required or invalid token
- `FORBIDDEN` - Insufficient permissions
- `NOT_FOUND` - Resource not found
- `VALIDATION_ERROR` - Request validation failed
- `INTERNAL_ERROR` - Server error

## Rate Limiting
- 100 requests per minute for authenticated requests
- 20 requests per minute for unauthenticated requests
- Rate limit headers included in response:
  - `X-RateLimit-Limit`
  - `X-RateLimit-Remaining`
  - `X-RateLimit-Reset`

## Pagination
List endpoints support pagination:

```
GET /users?page=2&limit=20&sort=created_at:desc
```

Response includes pagination metadata:
```json
{
  "data": [...],
  "pagination": {
    "page": 2,
    "limit": 20,
    "total": 150,
    "total_pages": 8
  }
}
```

## Versioning
The API version is included in the URL path (e.g., `/v1/`). 

## CORS
CORS is enabled for all origins in development. Production CORS settings:
- Allowed origins: `https://app.example.com`, `https://www.example.com`
- Allowed methods: `GET`, `POST`, `PUT`, `DELETE`, `OPTIONS`
- Allowed headers: `Content-Type`, `Authorization`

## Webhooks
Webhooks can be configured for certain events:
- `user.created`
- `user.updated`
- `user.deleted`

## SDKs
Official SDKs available:
- JavaScript/TypeScript
- Python
- C#
- Go

## Support
- API Status: https://status.example.com
- Documentation: https://docs.example.com
- Support: api-support@example.com
EOF
    
    log_event "SUCCESS" "API_DESIGN" "API documentation generated"
}

# Generate GraphQL schema
generate_graphql_schema() {
    local output_file="$API_STATE/specs/schema.graphql"
    
    log_event "INFO" "API_DESIGN" "Generating GraphQL schema"
    
    cat > "$output_file" << 'EOF'
scalar DateTime
scalar UUID
scalar Email

type Query {
  # User queries
  user(id: UUID!): User
  users(filter: UserFilter, pagination: PaginationInput): UserConnection!
  me: User
  
  # Search
  search(query: String!, type: SearchType): SearchResults!
}

type Mutation {
  # Authentication
  login(input: LoginInput!): AuthPayload!
  refresh(refreshToken: String!): AuthPayload!
  logout: Boolean!
  
  # User mutations
  createUser(input: CreateUserInput!): User!
  updateUser(id: UUID!, input: UpdateUserInput!): User!
  deleteUser(id: UUID!): Boolean!
  
  # Password
  changePassword(oldPassword: String!, newPassword: String!): Boolean!
  requestPasswordReset(email: Email!): Boolean!
  resetPassword(token: String!, newPassword: String!): Boolean!
}

type Subscription {
  userUpdated(userId: UUID): User!
  userStatusChanged: UserStatusUpdate!
}

# Types
type User {
  id: UUID!
  email: Email!
  name: String!
  role: UserRole!
  status: UserStatus!
  avatar: String
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Relations
  posts(pagination: PaginationInput): PostConnection!
  permissions: [Permission!]!
}

type AuthPayload {
  accessToken: String!
  refreshToken: String!
  tokenType: String!
  expiresIn: Int!
  user: User!
}

type Permission {
  id: UUID!
  name: String!
  resource: String!
  action: String!
}

type Post {
  id: UUID!
  title: String!
  content: String!
  status: PostStatus!
  author: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  publishedAt: DateTime
}

# Enums
enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum SearchType {
  USER
  POST
  ALL
}

# Input types
input LoginInput {
  email: Email!
  password: String!
}

input CreateUserInput {
  email: Email!
  name: String!
  password: String!
  role: UserRole = USER
}

input UpdateUserInput {
  email: Email
  name: String
  status: UserStatus
  avatar: String
}

input UserFilter {
  status: UserStatus
  role: UserRole
  search: String
}

input PaginationInput {
  page: Int = 1
  limit: Int = 20
  sortBy: String
  sortOrder: SortOrder = DESC
}

enum SortOrder {
  ASC
  DESC
}

# Connections (for pagination)
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  cursor: String!
  node: User!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PostEdge {
  cursor: String!
  node: Post!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

# Search
union SearchResult = User | Post

type SearchResults {
  results: [SearchResult!]!
  totalCount: Int!
  facets: SearchFacets!
}

type SearchFacets {
  types: [TypeFacet!]!
}

type TypeFacet {
  type: String!
  count: Int!
}

# Real-time updates
type UserStatusUpdate {
  userId: UUID!
  previousStatus: UserStatus!
  newStatus: UserStatus!
  timestamp: DateTime!
}
EOF
    
    log_event "SUCCESS" "API_DESIGN" "GraphQL schema generated"
}

# Main execution
main() {
    show_banner
    
    case "${1:-help}" in
        openapi)
            generate_openapi_spec "${2:-MyAPI}" "${3:-1.0.0}" "${4:-API generated by ZeroDev}"
            ;;
        sdk)
            generate_client_sdk "${2:-javascript}"
            ;;
        contracts)
            generate_contract_tests "${2:-jest}"
            ;;
        mock)
            generate_mock_server
            ;;
        docs)
            generate_api_docs "${2:-markdown}"
            ;;
        graphql)
            generate_graphql_schema
            ;;
        init)
            echo -e "${CYAN}Initializing API design...${NC}"
            generate_openapi_spec
            generate_client_sdk "javascript"
            generate_contract_tests
            generate_mock_server
            generate_api_docs
            echo -e "${GREEN}✓ API design initialized!${NC}"
            ;;
        *)
            echo "Usage: $0 {openapi|sdk|contracts|mock|docs|graphql|init} [options]"
            echo ""
            echo "Commands:"
            echo "  openapi [name] [ver] [desc] - Generate OpenAPI specification"
            echo "  sdk [language]              - Generate client SDK"
            echo "  contracts [framework]       - Generate contract tests"
            echo "  mock                        - Generate mock server"
            echo "  docs [format]               - Generate API documentation"
            echo "  graphql                     - Generate GraphQL schema"
            echo "  init                        - Initialize complete API design"
            exit 1
            ;;
    esac
}

main "$@"